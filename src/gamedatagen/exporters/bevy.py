"""
Bevy Game Engine Exporter

Exports game content to Bevy-compatible Rust formats (RON or JSON with serde)
"""

import json
from pathlib import Path
from typing import Any, Dict, List


class BevyExporter:
    """Export game content for Bevy game engine (Rust)"""

    def __init__(self, content_dir: Path) -> None:
        self.content_dir = content_dir

    def export(self, output_dir: Path, format: str = "ron") -> None:
        """
        Export all content to Bevy format

        Args:
            output_dir: Output directory
            format: Export format ('ron' or 'json')
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        # Export each entity type
        for entity_dir in self.content_dir.iterdir():
            if not entity_dir.is_dir() or entity_dir.name.startswith("_"):
                continue

            entity_type = entity_dir.name
            entities = self._load_entities(entity_dir)

            if format == "ron":
                self._export_ron(entities, entity_type, output_dir)
            else:  # json
                self._export_json(entities, entity_type, output_dir)

        # Generate Rust structs
        self._generate_rust_structs(output_dir)

        # Generate asset manifest
        self._generate_asset_manifest(output_dir, format)

    def _load_entities(self, entity_dir: Path) -> List[Dict[str, Any]]:
        """Load all entities from directory"""
        entities = []
        for entity_file in entity_dir.glob("*.json"):
            if entity_file.stem.startswith("_"):
                continue
            entities.append(json.loads(entity_file.read_text()))
        return entities

    def _export_ron(
        self, entities: List[Dict[str, Any]], entity_type: str, output_dir: Path
    ) -> None:
        """Export entities to RON (Rusty Object Notation)"""
        output_file = output_dir / f"{entity_type}.ron"

        # Convert to RON format
        ron_content = self._to_ron(entities)

        output_file.write_text(
            f"""// {entity_type} - Generated by GameDataGen for Bevy
// Use with bevy_asset_loader or load manually with asset_server.load()

{ron_content}
"""
        )

    def _export_json(
        self, entities: List[Dict[str, Any]], entity_type: str, output_dir: Path
    ) -> None:
        """Export entities to JSON (serde-compatible)"""
        output_file = output_dir / f"{entity_type}.json"

        output_file.write_text(json.dumps(entities, indent=2))

    def _to_ron(self, data: Any) -> str:
        """Convert Python data to RON format"""
        if isinstance(data, dict):
            # RON struct syntax
            items = []
            for key, value in data.items():
                ron_value = self._to_ron(value)
                items.append(f"  {key}: {ron_value}")

            return "(\n" + ",\n".join(items) + "\n)"

        elif isinstance(data, list):
            # RON array syntax
            if not data:
                return "[]"

            items = [self._to_ron(item) for item in data]
            return "[\n  " + ",\n  ".join(items) + "\n]"

        elif isinstance(data, str):
            # RON string syntax
            return f'"{data}"'

        elif isinstance(data, bool):
            # RON boolean (lowercase)
            return str(data).lower()

        elif isinstance(data, (int, float)):
            return str(data)

        elif data is None:
            return "None"

        else:
            return str(data)

    def _generate_rust_structs(self, output_dir: Path) -> None:
        """Generate Rust struct definitions"""
        rust_file = output_dir / "entities.rs"

        rust_code = """// Generated Rust structs for Bevy
// Copy these into your Bevy project

use bevy::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, Component)]
pub struct Quest {
    pub id: String,
    pub name: String,
    pub description: String,
    pub quest_giver: Option<String>,
    pub level_requirement: i32,
    pub objectives: Vec<String>,
    pub rewards: QuestRewards,
    pub quest_type: QuestType,
    pub zone: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuestRewards {
    pub xp: i32,
    pub gold: i32,
    pub items: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum QuestType {
    Main,
    Side,
    Daily,
    Event,
}

#[derive(Debug, Clone, Serialize, Deserialize, Component)]
pub struct NPC {
    pub id: String,
    pub name: String,
    pub race: String,
    pub class: String,
    pub level: i32,
    pub personality: Option<String>,
    pub role: NPCRole,
    pub dialogue: Vec<String>,
    pub location: Option<Location>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum NPCRole {
    Merchant,
    QuestGiver,
    Trainer,
    Guard,
}

#[derive(Debug, Clone, Serialize, Deserialize, Component)]
pub struct Item {
    pub id: String,
    pub name: String,
    pub item_type: ItemType,
    pub rarity: Rarity,
    pub level_requirement: Option<i32>,
    pub description: String,
    pub stats: Option<serde_json::Value>,
    pub value: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ItemType {
    Weapon,
    Armor,
    Consumable,
    QuestItem,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Rarity {
    Common,
    Uncommon,
    Rare,
    Epic,
    Legendary,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Location {
    pub zone: String,
    pub position: Position,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

// Asset loading helpers for Bevy

#[derive(Resource)]
pub struct GameAssets {
    pub quests: Handle<QuestCollection>,
    pub npcs: Handle<NPCCollection>,
    pub items: Handle<ItemCollection>,
}

#[derive(Asset, TypePath, Serialize, Deserialize)]
pub struct QuestCollection {
    pub quests: Vec<Quest>,
}

#[derive(Asset, TypePath, Serialize, Deserialize)]
pub struct NPCCollection {
    pub npcs: Vec<NPC>,
}

#[derive(Asset, TypePath, Serialize, Deserialize)]
pub struct ItemCollection {
    pub items: Vec<Item>,
}

// Example: Loading assets in Bevy
pub fn load_game_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
) {
    let assets = GameAssets {
        quests: asset_server.load("quests.ron"),
        npcs: asset_server.load("npcs.ron"),
        items: asset_server.load("items.ron"),
    };

    commands.insert_resource(assets);
}
"""

        rust_file.write_text(rust_code)

    def _generate_asset_manifest(self, output_dir: Path, format: str) -> None:
        """Generate asset manifest for Bevy asset loader"""
        manifest_file = output_dir / "manifest.ron"

        manifest = f"""// Asset manifest for bevy_asset_loader
// Add this to your assets/ directory

(
    format: "{format}",
    assets: [
        "quests.{format}",
        "npcs.{format}",
        "items.{format}",
        "enemies.{format}",
        "zones.{format}",
    ],
)
"""

        manifest_file.write_text(manifest)

        # Also create README
        readme = output_dir / "README.md"
        readme.write_text(
            f"""# Bevy Game Assets

Generated by GameDataGen for Bevy game engine.

## Setup

1. Copy `entities.rs` into your Bevy project's `src/` directory
2. Copy all `.{format}` files into your `assets/` directory
3. Add dependencies to `Cargo.toml`:

```toml
[dependencies]
bevy = "0.14"
serde = {{ version = "1.0", features = ["derive"] }}
serde_json = "1.0"  # If using JSON format
```

## Loading Assets

### Option 1: Manual Loading

```rust
use bevy::prelude::*;

fn setup(asset_server: Res<AssetServer>) {{
    let quests = asset_server.load("quests.{format}");
    // ...
}}
```

### Option 2: Using bevy_asset_loader

```rust
use bevy::prelude::*;
use bevy_asset_loader::prelude::*;

#[derive(AssetCollection, Resource)]
struct GameAssets {{
    #[asset(path = "quests.{format}")]
    quests: Handle<QuestCollection>,

    #[asset(path = "npcs.{format}")]
    npcs: Handle<NPCCollection>,
}}
```

## Entity Types

- **Quests**: Main/side quests with objectives and rewards
- **NPCs**: Non-player characters with dialogue and roles
- **Items**: Weapons, armor, consumables, quest items
- **Enemies**: Monsters and bosses
- **Zones**: Game areas and environments

## Customization

The generated `entities.rs` provides base structs. Extend them with:
- Bevy `Component` derives for ECS
- Custom behavior traits
- Additional fields specific to your game

## Example Usage

```rust
fn spawn_npc(
    mut commands: Commands,
    npc_data: &NPC,
    asset_server: Res<AssetServer>,
) {{
    commands.spawn((
        SpriteBundle {{
            texture: asset_server.load("textures/npcs/{{npc_data.id}}.png"),
            transform: Transform::from_xyz(
                npc_data.location.as_ref().unwrap().position.x,
                npc_data.location.as_ref().unwrap().position.y,
                npc_data.location.as_ref().unwrap().position.z,
            ),
            ..default()
        }},
        npc_data.clone(),
    ));
}}
```
"""
        )
